### 数据

#### 分段
|命令|描述|类型|是否初始化|占用文件大小|
|---|---|---|---|---|
|.section .data  |数据段    |变量|是 |声明的大小|
|.section .rodata|只读数据段|常量|是 |声明的大小|
|.section .bss   |bss段    |变量 |否 |较小空间，运行时才分配空间|

#### 声明举例
```
.section .data
output:
  .ascii "this cpu is xxxxxxxxxxxxxxxx\n"

.section .rodata
pi:
  .float 3.14159

.section .bss
  .lcomm sum, 6   /*声明一个sum变量，占用6字节*/

# 数组, 按声明顺序从低地址到高地址
.section .data
a:
  .byte 0x05, 0x02, 0x01, 0x08, 0x02  /* 小端序 */
```

#### data段支持的数据类型
|命令|描述|
|---:|---:|
| .ascii|                字符串|
|  asciz|       以\0结尾的字符串|
|  .byte|                      |
|.double|                      |
| .float|                      |
|   .int|             4字节整数|
|  .long|                 同int|
|  .octa|            16字节整数|
|  .quad|             8字节整数|
| .short|             2字节整数|
|.single| 单精度浮点数 同.float|

静态符号(常量，不允许修改)
```
.section .data
    .equ  factor,  3
    .equ  LINUX_SYS_CALL, 0x80

/*使用*/
int $LINUX_SYS_CALL
```

#### bss段支持的类型

|命令|描述|
|---:|---:|
| .comm |     通用内存|
| .lcomm| 本地通用内存|

### 传送
支持的字节数
|后缀|字节|
|---| ---|
|  q|   8|
|  l|   4|
|  w|   2|
|  b|   1|

#### 立即数到寄存器和内存
```
movl $0, %eax
movl $0x80, height       /*height是数据段声明的标签*/
```

#### 寄存器到寄存器
注意寄存器长度不同的情况
```
movl %eax, %ecx
movw %ax,  %cx
```

#### 内存和寄存器
```
movl  value, %eax
movl  %eax, value
/*变址寻址*/
movl $2, %edi
movl values(, %edi, 4), %eax
```
变址寻址
格式:  
base_address(offset_address, index, size)
计算方式:
base_address + offset_address + index * size
要求:
offset和index 必需是寄存器




#### 寄存器间接寻址
movl $output, %edi
movl %ebx, (%edi)
movl %edx, 4(%edi)    // &output+4
movl %edx, -4(%edi)  //  &output -4


#### 条件传送

cmovx source, destination

CF crray
OF overflow
PF  parity
SF  sign
ZF  zero

#### 数据交换

XCHG
BSWAP      --- 大小端转换




























